// This is the 'Offline page' service worker
const CACHE = '<isprint value="${Resource.msg('pwa.app.cache.name','pwa',null)}" encoding="off"/>';

// TODO: Handle offline fallback functionality;
const offlineFallbackPage = "${URLUtils.https("Pwa-Offline")}";
const staticAssets = <isinclude template="pwa/static_assets" />
const excludedPages = <isinclude template="pwa/excludes"/>

// Install stage sets up the offline page in the cache and opens a new cache
self.addEventListener('install', function (event) {
  console.log('Install Event processing');
  
  <iscomment> Allow skip waiting for updated worker: default = true </iscomment>
  <isif condition="${Resource.msg('pwa.app.skipWaiting','pwa',null)==="true"}">
  self.skipWaiting();
  </isif>

  event.waitUntil(
    caches.open(CACHE).then(function (cache) {
      console.log('Cached offline page during install');
      return cache.addAll(staticAssets);
    })
  );
});

self.addEventListener('activate', function (event) {
  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.filter(function(cacheName) {
          // Return true if you want to remove this cache,
          // but remember that caches are shared across
          // the whole origin
          // return cacheName === CACHE
        }).map(function(cacheName) {
          return caches.delete(cacheName);
        })
      );
    })
  );
});

<isif condition="${Resource.msg('pwa.app.sw.fetch.override','pwa',null)==="true"}">
    <isinclude template="pwa/sw_fetch_override" />
  <iselse/>
  // If any fetch fails, it will show the offline page.
  self.addEventListener('fetch', function (event) {
    if (event.request.method !== 'GET') return;
    var whitelistOpaque = <isprint value="${Resource.msg('pwa.app.opaque.whitelist','pwa',null)}" encoding="off"/>
    var useWhitelisting = whitelistOpaque.length > 0?true:false;
    var allowExcluding = <isprint value="${Resource.msg('pwa.app.allow.excluding','pwa',null)}" encoding="off"/>
    <isif condition="${Resource.msg('pwa.app.sw.cahe.strategy','pwa',null)==="CF"}">
     /**
     * Fetch from cache first if fails get from network, if both fails shoe generic offline page
     */
    event.respondWith(
      caches.match(event.request).then(function(response) {
        return response || fetch(event.request);
      }).catch(function() {
        if(offlineFallbackPage){
          // If both fail, show a generic fallback:
          return caches.match(offlineFallbackPage);
        }
      })
    )
    <iselseif condition="${Resource.msg('pwa.app.sw.cahe.strategy','pwa',null)==="NF"}" >
    /**
     * Fetch from network first if fails check cache, if both fails shoe generic offline page
     */
    event.respondWith(
      fetch(event.request).catch(function() {
        return caches.match(event.request).catch(function() {
          if(offlineFallbackPage){
            // If both fail, show a generic fallback:
            return caches.match(offlineFallbackPage);
          }
        })
      })
    )
    </iselseif>
    <iselse/>
    /**
     * Check cache for requested page if not found get it from network and cache at the same time
     * if both fails shoe generic offline page
     */
    event.respondWith(
      caches.open(CACHE).then(function(cache){
        return cache.match(event.request).then(function(response){
          var fetchPromise = fetch(event.request).then(function(networkResponse){
            
            <isif condition="${Resource.msg('pwa.app.no.opaque.cache','pwa',null)==="true"}">
              var requestUrl = new URL(event.request.url);

              if (networkResponse.type == "opaque" && networkResponse.status == 0) {
                if(useWhitelisting && (whitelistOpaque.includes(requestUrl.origin)|| whitelistOpaque.includes(requestUrl.href))){
                  cache.put(event.request, networkResponse.clone());
                }
              } else if(allowExcluding) {
                if(!excludedPages.includes(requestUrl.href)){
                  cache.put(event.request, networkResponse.clone());
                }
              }
              else {
                cache.put(event.request, networkResponse.clone());
              }
            <iselse/>  
                if(allowExcluding) {
                  if(!excludedPages.includes(requestUrl.href)){
                    cache.put(event.request, networkResponse.clone());
                  }
                }
                else {
                  cache.put(event.request, networkResponse.clone());
                }
            </isif>
            return networkResponse;
          })
          return response || fetchPromise;
        }).catch(function() {
          if(offlineFallbackPage){
            // If both fail, show a generic fallback:
            return caches.match(offlineFallbackPage);
          }
        })
      })
    )
    </isif>
  });
</isif>

// This is an event that can be fired from your page to tell the SW to update the offline page
self.addEventListener('refreshOffline', function () {
  const offlinePageRequest = new Request(offlineFallbackPage);

  return fetch(offlineFallbackPage).then(function (response) {
    return caches.open(CACHE).then(function (cache) {
      console.log('Offline page updated from refreshOffline event: ' + response.url);
      return cache.put(offlinePageRequest, response);
    });
  });
});

<isif condition="${Resource.msg('pwa.app.sw.extended','pwa',null)==="true"}">
  <isinclude template="pwa/sw_extended" />
</isif>